---
layout: post
title: "디자인 패턴이란 무엇인가?"
date: 2022-03-12
categories: DesignPattern
---

# 배경

모든 것이 마찬가지겠지만 프로그래밍에서도 시대마다 추구하는 가치가 변한다. 과거에는 절차지향 프로그래밍이 프로그래밍의 패러다임이였다면 현재는 객체지향이 프로그래밍의 패러다임이 되었다. 객체지향 패러다임은 코드의 확장성, 재사용성, 유연성 등을 프로그램의 주된 가치로 둔다.

# 디자인 패턴이란 무엇인가?

객체지향이 추가하는 가치를 지키기 위해 여러가지 설계 방법들이 발견되게 되었다. 이러한 설계 방법 중에 훌륭한 설계 방법들이 재사용되면서 패턴을 이루게 되었고 개발자들은 이러한 설계 패턴들을 모아서 디자인 패턴이라고 부르게 되었다.

# 디자인 패턴의 형식적 정의

Head First Design Pattern에는 디자인 패턴의 정의를 아래와 같이 하였다.

> 패턴이란 특정 컨텍스트 내에서 주어진 문제에 대한 해결책이다.  
> \-Head First Design Pattern-  
>   

여기서 주목해야 될 것은 문제, 컨텍스트, 해결책이다.

-   문제(problem): 문제는 객체지향이 추구하는 가치에 대한 방해 요소이다. 즉 프로그램의 확장성, 재사용성, 유연성을 방해하는 요소이다.

-   컨텍스트(context): 개발자가 문제에 처한 상황을 의미한다. 또 그 상황에서 존재하는 제약사항들도 포함한다.

-   해결책(solution): 컨텍스트에서 문제를 해결 할 수 있는 해결책을 의미한다. 이러한 해결책이 바로 디자인 패턴이다.

디자인 패턴의 형식적 정의에 대한 간단한 예를 들어보자면, 클래스가 특정 구상클래스의 메소드를 호출하여 의존하는 컨텍스트가 있다고 가정해본다. 이러한 컨텍스트는 확장성을 제한한다는 문제가 존재한다. 이러한 문제에 대한 해결책으로 특정 구상클래스를 interface로 캡슐화하여 의존성 주입을 통해서 사용하도록 하는 전략패턴이 해결책이 될 수 있을 것이다.

# 디자인 패턴의 분류

디자인패턴에 가장 권위있는 책은 GoF의 디자인패턴에서는 용도에 따라 세가지로 분류하였다.

-   생성(creational pattern): 인스턴스를 생성하기 위한 용도로 설계 된 디자인 패턴이다.

-   행동(behavioral pattern): 클래스의 행동을 정의하기 위해 다른 클래스의 관계를 나타내는 디자인 패턴이다.

-   구조(structural pattern): 클래스 및 객체의 구성을 통해서 새로운 구조를 나타내는 디자인 패턴이다.

# 분류에 따른 예시

| 생성(creational pattern) | 행동(behavioral pattern) | 구조(structural pattern) |
| --- | --- | --- |
| Singleton | Command | Adapter |
| Abstract Factory | Interpreter | Composite |
| Factory Method | Iterator | Decorator |
| Builder | Mediator | Facade |
| Prototype | Memento | Flyweight |
| Factory Method | Observer | Proxy |
|   | State |   |
|   | Strategy |   |
|   | Template Method |   |
|   | State |   |

<!-- ## 4. 디자인의 일반적 원칙

디자인 패턴이 발달하면서 일반적인 개발 원칙들이 생겨놨다. Hedafirst Disign Pattern의 내용을 참조하여 일반적인 원칙을 설명하였다. 그 일반적인 개발원칙은 아래와 같다.

### 4.1 어플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분으로부터 분리시킨다.

외부의 영향에 의해 어플리케이션은 항상 변화 할 가능성을 가지고 있다. 이 변화에 의해 어플리케이션의 어느 부분이 변화하게 될 것이고 어느 부분이 변화하지 않을 것인지 판단하는 것은 설계의 과정에서 어려운 문제이면서 중요한 과제이다. 왜냐하면 외부의 영향에 의해서 어떤 부분이 변화하게 될지 완벽하게 예상할 수 없기 때문에 어려운 문제이기도 하지만 변화하게 되는 부분을 분리시켜 관리함으로써 변화에 대한 개발이 발생할 때 그 부분만 고치거나 확장 할 수 있기도 하기 때문이다. 그리고 이것이 설계의 첫단계이기도 하다.

### 4.2 구현이 아닌 인터페이스에 맞추어 프로그래밍한다.

여기서 구현이라함은 클래스에 행동들을 메소드로 직접 구현함을 의미한다. 인터페이스에 맞추어 프로그래밍한다는 의미는 클래스에 모든 행동을 구현하지 않고 클래스를 클라이언트로 상정하고 행동들을 인터페이스를 이용한 api로 구현하여 클라이언트 측에서는 인터페이스의 구현체를 모른체 호출 할 수 있도록 프로그래밍 하는 것을 의미한다. 이렇게 함으로써 클라이언트측 개발자는 특정행동에 대한 구현체를 분석할 필요 없이 행동의 기능만 알고 있다면 인터페이스를 통해서 호출 할 수 있다. 그리고 런타임시 다른 행동이 필요한 경우 인터페이스에 같은 타입의 다른 행동을 주입함으로써 행동을 바꿀 수 있다. 마지막으로 행동에 대한 확장이 필요한 경우 인터페이스를 구현함으로써 확장 할 수 있다.

### 4.3 상속보다 구성을 활용한다.

이미 구현되어 있는 메소드를 호출하는 방법에는 두 가지가 존재 할 수 있다. 상속 된 메소드를 호출하는 방법과 구성(composition)을 이용하여 호출하는 방법이다. 구성을 이용하여 호출하는 방법의 대표적인 예는 멤버 변수를 통한 호출이 있을 수 있다. 상속 된 메소드의 호출은 다형성이 없기 때문에 유연하지 않다. 해당 호출은 한가지의 행동으로만 구현되어 있다. 하지만 구성을 이용하여 호출하는 방법에는 다형성이 적용 될 수 있기 때문에 유연하다. 4.3 원칙은 사실 4.2의 확장 된 원칙이다. 왜냐하면 인터페이스를 사용하여 캡슐화 된 구현 클래스들은 해당 인터페이스 타입으로 호출 될 수 있기 때문이다.

### 4.4 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야한다.

느슨한 결합(loose coupling)이란 한 객체가 어떤 클래스타입에 의존한다고 할 때 클래스타입이 구체적인 구현클래스 타입이 아닌 추상적인 추상클래스나 인터페이스를 통해서 의존하는 것을 말한다. 구체적인 구현클래스 타입은 컴파일이 완료되면 호출시 제공되는 내용이 구현클래스에 국한되어 두 객체 관계 단단하게 결합되어 버린다. 하지만 추상적인 클래스 타입에 의존하면 컴파일이 완료된 후에도 추상클래스나 인터페이스의 구현체들로 범위가 확대되어 런타임시에 교체 될 수 있는 가능성이 생긴다. 이러한 객체들 사이의 관계를 느슨한 결합이라고 한다. -->
