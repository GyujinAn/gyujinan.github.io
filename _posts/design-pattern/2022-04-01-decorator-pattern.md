---
layout: post
title: "데코레이터 패턴(decorator pattern)"
date: 2022-04-01
categories: DesignPattern
---

# 데코레이터 패턴(decorator pattern)

## 1. 왜 데코레이터 패턴을 사용하는가? 

### 1.1 객체의 Optional 로직의 특성

개발을 진행하다보면 Optional하게 주요로직 전후에 실행되는 로직들이 존재한다. buffer를 사용한다거나 인증처리를 하는 로직들이 이와 같은 로직이라고 말 할 수 있다. 이러한 로직들은 런타임시 상황에 따라 필요 할 수 있고 필요하지 않을 수도 있다. 그러므로 Optional한 로직과 주요로직은 분리되어 개발되어져야한다. 주요로직과 Optional한 로직은 하나의 함수나 메소드에 넣어서 개발한다면 컴파일 후에는 두 로직은 항상 함께 사용되어 질 것이다.

## 2. 데코레이터 패턴이란 무엇인가?

### 2.1 데코레이터 패턴의 정의

데코레이터 패턴이란 주요로직과 Optional한 로직을 서로 다른 클래스로 분리하여 런타임시 첨가하는 방법으로 유연성과 확장성을 보장해주는 디자인 패턴이다. 

### 2.2 데코레이터 패턴의 구조

![decorator-pattern-01](/public/images/decorator-pattern-01.png)

데코레이터 패턴은 Component와 Decorator 두 종류의 클래스로 크게 나눌 수 있고 Decorator클래스는 Component를 상속하고 있다. Component에는 클라이언트에게 제공할 메소드 시그니처를 선언해야한다. 해당 메소드는 하나의 시그니처로 클라이언트에 제공되지만 런타임시에는 Optional한 로직과 주요로직을 순차적으로 실행하게 된다. 주요로직은 Component를 상속한 ConcreteComponent에 구현되고 Optional한 로직은 Decorator를 상속한 ConcreteDecorator에 구현된다.

### 2.3 데코레이터 패턴의 구현

### 2.4 데코레이터 패턴의 사용

## 3. 데코레이터 패턴의 한계

객체지향적 개발은 최대한 클라이언트 측에서 구상클래스에 의존하지 않도록 해야한다. 데코레이터 패턴은 인스턴스를 생성시점 이후로 구상클래스에 의존하지 않도록 개발되지만 인스턴스를 생성하는 시점에 component와 decorator의 구상클래스에 의존 할 수 밖에 없다는 한계를 가지고 있다. 이러한 한계를 극복하기 위해서는 팩토리 패턴을 사용하여 인스턴스 생성을 클라이언트 측 코드로 부터 분리해야 한다.

## 4. 데코레이터 패턴 사례

<!-- spring MVC에서 제공되는 필터를 조사해보자 -->